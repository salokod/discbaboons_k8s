name: Test & Deploy

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:17-alpine
        env:
          POSTGRES_PASSWORD: testpassword
          POSTGRES_USER: testuser
          POSTGRES_DB: discbaboons_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: apps/express-server/package-lock.json
          
      - name: Install dependencies
        working-directory: apps/express-server
        run: npm ci
        
      - name: Generate Prisma client
        working-directory: apps/express-server
        run: npm run db:generate
        
      - name: Run database migrations
        working-directory: apps/express-server
        env:
          DATABASE_URL: postgresql://testuser:testpassword@localhost:5432/discbaboons_test
        run: |
          # Install Flyway CLI
          wget -qO- https://repo1.maven.org/maven2/org/flywaydb/flyway-commandline/10.8.1/flyway-commandline-10.8.1-linux-x64.tar.gz | tar -xvz
          sudo ln -s $(pwd)/flyway-10.8.1/flyway /usr/local/bin
          
          # Run migrations
          flyway -url=jdbc:postgresql://localhost:5432/discbaboons_test -user=testuser -password=testpassword -locations=filesystem:../../migrations migrate
        
      - name: Run tests
        working-directory: apps/express-server
        env:
          DATABASE_URL: postgresql://testuser:testpassword@localhost:5432/discbaboons_test
          NODE_ENV: test
          FORCE_COLOR: true
        run: npm run verify

  deploy:   
    needs: test  
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Important: semantic-release needs full git history
        token: ${{ secrets.GITHUB_TOKEN }}
        persist-credentials: true

    - name: ğŸ” Check for migration changes
      id: migration-check
      run: |
        echo "ğŸ” Checking if migrations need to be applied first..."
        
        if [ "${{ github.event.before }}" = "0000000000000000000000000000000000000000" ]; then
          echo "migrations-needed=false" >> $GITHUB_OUTPUT
          echo "âœ… First commit - no migration check needed"
          exit 0
        fi
        
        MIGRATION_CHANGES=$(git diff --name-only ${{ github.event.before }}..${{ github.sha }} | grep "^migrations/V.*\.sql$" | wc -l)
        
        if [ "$MIGRATION_CHANGES" -gt 0 ]; then
          echo "migrations-needed=true" >> $GITHUB_OUTPUT
          echo "âœ… Migration changes detected - will apply before app deployment"
          echo "Changed migrations:"
          git diff --name-only ${{ github.event.before }}..${{ github.sha }} | grep "^migrations/V.*\.sql$"
        else
          echo "migrations-needed=false" >> $GITHUB_OUTPUT
          echo "ğŸ“­ No migration changes - proceeding with app-only deployment"
        fi

    - name: ğŸ“‹ Setup Node.js for semantic-release
      uses: actions/setup-node@v4
      with:
        node-version: '22'
        cache: 'npm'
        cache-dependency-path: apps/express-server/package-lock.json

    - name: ğŸ“¦ Install semantic-release dependencies
      working-directory: apps/express-server
      run: npm ci

    - name: ğŸ” Check if Express app changed
      id: changes
      run: |
        # Check if express app files changed
        if [ "${{ github.event.before }}" = "0000000000000000000000000000000000000000" ]; then
          # First commit, assume changes
          echo "changed=true" >> $GITHUB_OUTPUT
          echo "âœ… First commit - assuming Express app changes"
        else
          EXPRESS_CHANGES=$(git diff --name-only ${{ github.event.before }}..${{ github.sha }} | grep "^apps/express-server/" | wc -l)
          
          if [ "$EXPRESS_CHANGES" -eq 0 ]; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "ğŸš« No Express app changes detected"
          else
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "âœ… Express app changes detected:"
            git diff --name-only ${{ github.event.before }}..${{ github.sha }} | grep "^apps/express-server/"
          fi
        fi

    - name: ğŸ·ï¸ Generate semantic version
      if: steps.changes.outputs.changed == 'true'
      id: semantic
      working-directory: apps/express-server
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Install dependencies if not cached
        npm ci
        
        # Run semantic-release to get next version and create release
        npx semantic-release --dry-run > semantic-output.txt 2>&1 || true
        
        # Debug: show output
        echo "Semantic-release output:"
        cat semantic-output.txt
        
        # Extract version from output (handle both cases)
        NEXT_VERSION=$(grep -oE "(T|t)he next release version is [0-9]+\.[0-9]+\.[0-9]+" semantic-output.txt | grep -oE "[0-9]+\.[0-9]+\.[0-9]+" || echo "")
        
        if [ -z "$NEXT_VERSION" ]; then
          echo "No version change detected by semantic-release"
          echo "version_changed=false" >> $GITHUB_OUTPUT
          # Get current version from package.json
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
        else
          echo "Next version: $NEXT_VERSION"
          echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "version_changed=true" >> $GITHUB_OUTPUT
        fi

    - name: ğŸ·ï¸ Create actual release
      if: steps.changes.outputs.changed == 'true' && steps.semantic.outputs.version_changed == 'true'
      working-directory: apps/express-server
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Run semantic-release for real to create the release
        echo "Creating actual release..."
        npx semantic-release

    - name: ğŸ³ Login to Docker Hub
      if: steps.changes.outputs.changed == 'true' && steps.semantic.outputs.version_changed == 'true'
      run: |
        echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

    - name: ğŸ—ï¸ Build Docker image
      if: steps.changes.outputs.changed == 'true' && steps.semantic.outputs.version_changed == 'true'
      working-directory: apps/express-server
      run: |
        VERSION="${{ steps.semantic.outputs.version }}"
        SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
        IMAGE_TAG="v${VERSION}-${SHORT_SHA}"
        echo "Building: salokod/discbaboons-express:${IMAGE_TAG}"
        docker build -t salokod/discbaboons-express:${IMAGE_TAG} .
        echo "tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
      id: build
        
    - name: ğŸ“¤ Push to Docker Hub
      if: steps.changes.outputs.changed == 'true' && steps.semantic.outputs.version_changed == 'true'
      run: |
        IMAGE_TAG="${{ steps.build.outputs.tag }}"
        echo "Pushing: salokod/discbaboons-express:${IMAGE_TAG}"
        docker push salokod/discbaboons-express:${IMAGE_TAG}

    - name: âš™ï¸ Setup kubectl and doctl
      if: steps.migration-check.outputs.migrations-needed == 'true' || (steps.changes.outputs.changed == 'true' && steps.semantic.outputs.version_changed == 'true')
      run: |
        # Install kubectl
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        
        # Install doctl
        cd /tmp
        wget https://github.com/digitalocean/doctl/releases/download/v1.104.0/doctl-1.104.0-linux-amd64.tar.gz
        tar xf doctl-1.104.0-linux-amd64.tar.gz
        sudo mv doctl /usr/local/bin
        
        # Authenticate and configure kubectl
        doctl auth init --access-token ${{ secrets.DO_API_TOKEN }}
        doctl kubernetes cluster kubeconfig save discbaboons-production
        
        # Test connection
        kubectl get nodes

    - name: ğŸ—„ï¸ Apply database migrations
      if: steps.migration-check.outputs.migrations-needed == 'true'
      run: |
        echo "ğŸš€ Applying database migrations to production..."
        
        # Update migrations ConfigMap
        echo "ğŸ“¦ Updating migrations ConfigMap..."
        kubectl delete configmap flyway-migrations --ignore-not-found=true
        kubectl create configmap flyway-migrations --from-file=migrations/
        
        # Apply production Flyway config
        echo "ğŸ“‹ Applying production Flyway configuration..."
        kubectl apply -f manifests/prod/flyway-configmap.yaml
        
        # Create unique migration job
        MIGRATION_JOB="flyway-migration-$(date +%s)"
        echo "ğŸ”§ Creating migration job: $MIGRATION_JOB"
        
        cat << EOF | kubectl apply -f -
        apiVersion: batch/v1
        kind: Job
        metadata:
          name: $MIGRATION_JOB
          labels:
            app: flyway
            environment: prod
            deployment-migration: "true"
        spec:
          ttlSecondsAfterFinished: 300
          template:
            metadata:
              labels:
                app: flyway
                environment: prod
            spec:
              restartPolicy: Never
              containers:
              - name: flyway
                image: flyway/flyway:10.8.1
                command: ["/bin/sh"]
                args:
                  - -c
                  - |
                    echo "ğŸš€ Running production database migration..."
                    echo "Migration files:"
                    ls -la /flyway/sql/
                    echo ""
                    flyway migrate
                    echo ""
                    echo "âœ… Migration completed! Final status:"
                    flyway info
                envFrom:
                - configMapRef:
                    name: flyway-config
                env:
                - name: FLYWAY_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: postgres-secret
                      key: app-password-new
                volumeMounts:
                - name: migrations
                  mountPath: /flyway/sql
              volumes:
              - name: migrations
                configMap:
                  name: flyway-migrations
        EOF
        
        # Wait for migration to complete
        echo "â³ Waiting for migration to complete (5 minute timeout)..."
        kubectl wait --for=condition=complete job/$MIGRATION_JOB --timeout=300s
        
        # Show migration results
        echo "ğŸ“‹ Migration results:"
        kubectl logs job/$MIGRATION_JOB --tail=50
        
        echo "âœ… Database migrations completed successfully!"

    - name: ğŸš€ Deploy to Kubernetes
      if: steps.changes.outputs.changed == 'true' && steps.semantic.outputs.version_changed == 'true'
      run: |
        IMAGE_TAG="${{ steps.build.outputs.tag }}"
        NEW_IMAGE="salokod/discbaboons-express:${IMAGE_TAG}"
        
        echo "ğŸš€ Deploying new image: ${NEW_IMAGE}"
        
        # If migrations ran, wait a moment for database to be ready
        if [ "${{ steps.migration-check.outputs.migrations-needed }}" = "true" ]; then
          echo "â³ Migrations completed - waiting 10 seconds for database to stabilize..."
          sleep 10
        fi
        
        echo "ğŸ“ Current production image:"
        kubectl get deployment express-deployment -o jsonpath='{.spec.template.spec.containers[0].image}'
        echo ""
        
        # Update the deployment with new image
        kubectl set image deployment/express-deployment express=${NEW_IMAGE}
        
        # Wait for rollout to complete (5 minute timeout)
        echo "â³ Waiting for deployment to complete..."
        kubectl rollout status deployment/express-deployment --timeout=300s
        
        # Verify deployment success
        echo "âœ… Deployment completed! New pods:"
        kubectl get pods -l app=express -o wide
        
        echo "ğŸ¯ Verified new image in deployment:"
        kubectl get deployment express-deployment -o jsonpath='{.spec.template.spec.containers[0].image}'
        echo ""
        
        echo "ğŸŒ Your app is live at: https://discbaboons.spirojohn.com"

    - name: ğŸ“ Create GitHub Release
      if: steps.changes.outputs.changed == 'true' && steps.semantic.outputs.version_changed == 'true'
      working-directory: apps/express-server
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Run semantic-release to create actual release
        npm run semantic-release

    - name: ğŸ“¢ Deployment Success Notification
      if: success() && (steps.changes.outputs.changed == 'true' && steps.semantic.outputs.version_changed == 'true' || steps.migration-check.outputs.migrations-needed == 'true')
      run: |
        echo "ğŸ‰ DEPLOYMENT SUCCESSFUL!"
        echo "=========================="
        if [ "${{ steps.migration-check.outputs.migrations-needed }}" = "true" ]; then
          echo "âœ… Database: Migrations applied"
        fi
        if [ "${{ steps.changes.outputs.changed }}" = "true" ] && [ "${{ steps.semantic.outputs.version_changed }}" = "true" ]; then
          echo "âœ… App: https://discbaboons.spirojohn.com"
          echo "ğŸ·ï¸ Image: salokod/discbaboons-express:${{ steps.build.outputs.tag }}"
          echo "ğŸ“¦ Version: ${{ steps.semantic.outputs.version }}"
        fi
        echo "â° Time: $(date)"
        echo "ğŸ‘¤ Deployed by: ${{ github.actor }}"
        echo "ğŸ“ Commit: ${{ github.event.head_commit.message }}"
        echo "ğŸ”— Logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        
    - name: ğŸš¨ Deployment Failure Alert
      if: failure()
      run: |
        echo "âŒ DEPLOYMENT FAILED!"
        echo "===================="
        echo "ğŸ” Check logs immediately: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        echo "ğŸ“§ Alert team for immediate investigation"
        echo "ğŸ”„ Consider emergency rollback if needed"

    - name: âœ… Migration-only deployment
      if: steps.migration-check.outputs.migrations-needed == 'true' && (steps.changes.outputs.changed == 'false' || steps.semantic.outputs.version_changed == 'false')
      run: |
        echo "âœ… MIGRATION-ONLY DEPLOYMENT COMPLETED"
        echo "====================================="
        echo "âœ… Database: Migrations applied successfully"
        echo "ğŸ“­ Express: No app changes to deploy"
        echo "ğŸŒ App: https://discbaboons.spirojohn.com (schema updated)"
        echo "â° Completed: $(date)"

    - name: â„¹ï¸ No deployment needed
      if: steps.changes.outputs.changed == 'false' && steps.migration-check.outputs.migrations-needed == 'false'
      run: |
        echo "ğŸš« No deployment needed"
        echo "ğŸ“ No Express app changes detected"
        echo "ğŸ—„ï¸ No migration changes detected"
        echo "Changed files:"
        git diff --name-only ${{ github.event.before }}..${{ github.sha }} || echo "Unable to detect changes"
        echo "âœ… Repository is up to date"

    - name: â„¹ï¸ No app deployment needed
      if: steps.changes.outputs.changed == 'true' && steps.semantic.outputs.version_changed == 'false' && steps.migration-check.outputs.migrations-needed == 'false'
      run: |
        echo "ğŸš« No app deployment needed"
        echo "ğŸ“ Express app changed but no semantic version bump warranted"
        echo "ğŸ’¡ Commits don't follow conventional commit format or are non-releasable"
        echo "ğŸ·ï¸ Current version: ${{ steps.semantic.outputs.version }}"
        echo "âœ… Skipping build and deployment"